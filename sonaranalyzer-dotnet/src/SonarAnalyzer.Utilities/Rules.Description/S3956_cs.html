<p><code>System.Collections.Generic.List&lt;T&gt;</code> 是为性能而非继承设计的泛型集合。举例来说，他不包含能更方便地让继承类更改行为的virtual型成员。这意味着之后尝试扩充行为的努力都是无用的，因为扩展点（extension point）不在其中。所以相反地，应使用下列的某一泛型集合：</p>
<ul>
  <li> <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Generic.ICollection&lt;TKey&gt;</code> </li>
  <li> <code>System.Collections.Generic.IReadOnlyList&lt;T&gt;</code> </li>
  <li> <code>System.Collections.Generic.IList&lt;TKey&gt;</code> </li>
  <li> <code>System.Collections.ObjectModel.Collection&lt;T&gt;</code> </li>
  <li> <code>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</code> </li>
  <li> <code>System.Collections.ObjectModel.KeyedCollection&lt;TKey, Titem&gt;</code> </li>
</ul>
<p>此规则会在每次 <code>System.Collections.Generic.List&lt;T&gt;</code> 以下列方式暴露时引发一个问题：</p>
<ul>
  <li> 作为一个外部可见的成员。 </li>
  <li> 作为一个外部可见方法的返回的类型 </li>
  <li> 作为一个外部可见方法的参数类型 </li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
namespace Foo
{
   public class Bar
   {
      public List&lt;T&gt; Method1(T arg) // 不合规
      {
           //……
      }
   }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
namespace Foo
{
   public class Bar
   {
      public Collection&lt;T&gt; Method1(T arg)
      {
           //……
      }
   }
}
</pre>

