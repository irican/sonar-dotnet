<p>由于.Net Framework的2.0版本，没有必要再去声明那些指定了 <code>System.EventArgs</code> 派生类的委托。应该使用 <code>System.EventHandler&lt;TEventArgs&gt;</code> 委托机制，因为它允许任何派生自 <code>EventArgs</code> 的类与该机制一起使用。</p>
<p>当旧式的委托用作事件处理器（event handler）时，此规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public class MyEventArgs : EventArgs
{
}

public delegate void MyEventHandler(object sender, MyEventArgs e); // 不合规

public class EventProducer
{
  public event MyEventHandler MyEvent;

  protected virtual void OnMyEvent(MyEventArgs e)
  {
    if (MyEvent != null)
    {
      MyEvent(e);
    }
  }
}

public class EventConsumer
{
  public EventConsumer(EventProducer producer)
  {
      producer.MyEvent += HandleEvent;
  }

  private void HandleEvent(object sender, MyEventArgs e)
  {
    // 此处进行一些操作
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class MyEventArgs : EventArgs
{
}

public class EventProducer
{
  public event EventHandler&lt;MyEventArgs&gt; MyEvent;

  protected virtual void OnMyEvent(MyEventArgs e)
  {
    if (MyEvent != null)
    {
      MyEvent(e);
    }
  }
}

public class EventConsumer
{
  public EventConsumer(EventProducer producer)
  {
      producer.MyEvent += HandleEvent;
  }

  private void HandleEvent(object sender, MyEventArgs e)
  {
    // 此处进行一些操作
  }
}
</pre>

