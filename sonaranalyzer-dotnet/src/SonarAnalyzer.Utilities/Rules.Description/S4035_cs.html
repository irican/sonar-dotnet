<p>当一个类实现了 <code>IEquatable&lt;T&gt;</code>接口时，它将进入一个契约，该契约实际上声明“我知道如何比较T类型的两个实例或从T派生的任何类型的实例，以获得相等性”。但是，如果派生了该类，基类就不太可能知道如何进行有意义的比较。因此，这种隐含的契约现在被打破了。</p>
<p>或者<code>IEqualityComparer&lt;T&gt;</code> 提供了一个更安全的接口，并被集合使用，或者<code>Equals</code> 可以被当作<code>virtual</code>。</p>
<p>当未密封的<code>public</code>或<code>protected</code> 类实现 <code>IEquitable&lt;T&gt;</code>，并且<code>Equals</code> 不是<code>virtual</code>时，此规则会引发问题。</p>
<h2>不合规的代码示例</h2>
<pre>
using System;

namespace MyLibrary
{
  class Base : IEquatable&lt;Base&gt; // 不合规
  {
    bool Equals(Base other)
    {
      if (other == null) { return false };
      // 比较基本属性
    }

    override bool Equals(object other)  =&gt; Equals(other as Base);
  }

  class A : Base
  {
    bool Equals(A other)
    {
      if (other == null) { return false };
      // 比较A属性
      return base.Equals(other);
    }

    override bool Equals(object other)  =&gt; Equals(other as A);
  }

  class B : Base
  {
    bool Equals(B other)
    {
      if (other == null) { return false };
      // 比较B属性
     return base.Equals(other);
    }

    override bool Equals(object other)  =&gt; Equals(other as B);
  }

  static void Main() {
    A a = new A();
    B b = new B();

    Console.WriteLine(a.Equals(b)); // 这调用了错误的等号。这导致调用Base::Equals(Base)，它只比较Base中的属性，而忽略了a和b是不同类型的事实。
    // 在工作示例中，A::Equals(Object)将被调用，Equals将返回false，因为它正确地识别出a和b是不同的类型。如果a和b具有相同的基本属性，它们将作为相等的返回。
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
using System;

namespace MyLibrary
{
    public sealed class Foo : IEquatable&lt;Foo&gt;
    {
        public bool Equals(Foo other)
        {
            // Your code here
        }
    }
}
</pre>
<h2>请参阅</h2>
<p><a href="http://blog.mischel.com/2013/01/05/inheritance-and-iequatable-do-not-mix/">Inheritance and IEquatable do not mix</a></p>
<p><a href="https://msdn.microsoft.com/en-us/library/ms132151(v=vs.110).aspx">IEqualityComparer&lt;T&gt; Interface</a></p>

