<p>在属性和索引器的 <code>set</code> 方法，以及事件的 <code>add</code> 和 <code>remove</code> 方法里，隐式 <code>value</code>的参数保存着调用访问器（accessor）时使用的值。不使用这个 <code>value</code> 意味着访问器无视了调用者的意图，这可能导致运行时出现意外的结果。</p>
<h2>不合规的代码示例</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = 42; } // 不合规
}
</pre>
<h2>合规的解决方案</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = value; }
}
</pre>
<p>或者</p>
<pre>
public int Count
{
  get { return count; }
  set { throw new InvalidOperationException(); }
}
</pre>
<h2>例外</h2>
<p>setter方法如果为空并且属于某个 <code>interface</code> 的实现时此规则不会引发问题。这里的假设是接口的这一部分对此次的特定的实现是没有意义的。一个丢弃任何日志的“sink”记录器（logger）就是个很好的例子。</p>

