<p>浮点数并不精确，因为它们是以二进制的形式存储的。而且浮点数是不满足结合律的（not associative）；对一个 <code>float</code> 或一个 <code>double</code> 进行一系列简单的数学运算，结果会随着运算顺序的改变而改变，因为每一步运算中都会进行舍入。</p>
<p>即使是赋值操作也并不简单：</p>
<pre>
float f = 0.100000001f; // 0.1
double d = 0.10000000000000001; // 0.1
</pre>
<p>(不同的编译器和编译器设置会得出不同的结果)</p>
<p>因此，几乎每次对 <code>float</code> 或 <code>double</code> 类型的值使用相等运算符（<code>==</code>）和不等运算符（<code>!=</code>）的行为都是错误的。</p>
<p>此规则检查所有针对浮点型和双精度浮点型的直接与间接的相等／不相等判断。</p>
<h2>不合规的代码示例</h2>
<pre>
float myNumber = 3.146f;
if ( myNumber == 3.146f ) //不合规。因为浮点数的值不精确，该语句的值为假
{
  // ...
}

if (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // 不合规，此处是间接的相等判断
{
  // ...
}

if (myNumber &lt; 4 || myNumber &gt; 4) // 不合规，间接的不相等判断
{
  // ...
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. </li>
  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality </li>
</ul>

