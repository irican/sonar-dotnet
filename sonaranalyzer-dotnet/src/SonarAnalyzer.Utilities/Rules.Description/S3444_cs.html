<p>当一个接口继承自两个具有同名成员的接口时，通过派生的接口访问该成员的行为会导致编译器错误 <code>CS0229 ‘IBase1.SomeProperty’和‘IBase2.SomeProperty’存在歧义</code>。</p>
<p>所以相反地，每个调用者都必须将子接口的实例强制转换为它的任一个父接口才能解决歧义的问题并成功访问这个成员。更好的方法是在子接口的定义里解决歧义问题：</p>
<ul>
  <li> 在某一个父接口里重命名这个成员以避免碰撞 </li>
  <li> 在子接口里也定义这个成员。但只有在该成员的所有拷贝都是相同的值时才能这样做 </li>
</ul>
<p> </p>
<h2>不合规的代码示例</h2>
<pre>
public interface IBase1
{
  string SomeProperty { get; set; }
}

public interface IBase2
{
  string SomeProperty { get; set; }
}

public interface IDerived : IBase1, IBase2 // 不合规，访问IDerived.SomeProperty的操作是有歧义的
{
}

public class MyClass : IDerived
{
  // 同时实现了 IBase1.SomeProperty 和 IBase2.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IBase1)myClass).SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IBase2)myClass).SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IDerived)myClass).SomeProperty); // 错误CS0229　‘IBase1.SomeProperty’与‘IBase2.SomeProperty’存在歧义
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public interface IDerived : IBase1, IBase2
{
  new string SomeProperty { get; set; }
}

public class MyClass : IDerived
{
  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IBase1)myClass).SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IBase2)myClass).SomeProperty); // 正确输出“Hello”
    Console.WriteLine(((IDerived)myClass).SomeProperty); // 正确输出“Hello”
  }
}
</pre>
<p>或者</p>
<pre>
public interface IBase1
{
  string SomePropertyOne { get; set; }
}

public interface IBase2
{
  string SomePropertyTwo { get; set; }
}

public interface IDerived : IBase1, IBase2
{
}
</pre>

