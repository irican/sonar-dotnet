<p>对<code>async</code>方法进行阻塞调用会将原本是异步的内容转换为同步块。这样做会导致死锁和上下文线程的意外阻塞。</p>
<p>根据MSDN文件：</p>
<blockquote>
  <p>死锁的根本原因是<code>await</code>处理上下文的方式。默认情况下，当等待一个不完整的 <code>Task</code> 时，将捕获当前的“上下文”，并在<code>Task</code>完成时用于恢复该方法。这个“上下文”是当前 <code>SynchronizationContext</code> 除非它是空的，否则它是当前 <code>TaskScheduler</code>。GUI 和 ASP.NET 应用程序有一个<code>SynchronizationContext</code>，它一次只允许运行一段代码。 当<code>await</code> 完成时，它尝试在捕获的上下文中执行 <code>async</code> 方法的其余部分。但是上下文中已经有一个线程，它(同步地)等待<code>async</code> 方法完成。他们都在等着对方，造成了死锁。</p>
</blockquote>
<table>
  <tbody>
    <tr>
      <th>执行此操作......</th>
      <th>而不是这个......</th>
      <th>使用这个</th>
    </tr>
    <tr>
      <td>检索后台任务的结果</td>
      <td><code>Task.Wait</code>, <code>Task.Result</code> 或 <code>Task.GetAwaiter.GetResult</code></td>
      <td><code>await</code></td>
    </tr>
    <tr>
      <td>等待任何任务完成</td>
      <td><code>Task.WaitAny</code></td>
      <td><code>await Task.WhenAny</code></td>
    </tr>
    <tr>
      <td>检索多个任务的结果</td>
      <td><code>Task.WaitAll</code></td>
      <td><code>await Task.WhenAll</code></td>
    </tr>
    <tr>
      <td>等一段时间</td>
      <td><code>Thread.Sleep</code></td>
      <td><code>await Task.Delay</code></td>
    </tr>
  </tbody>
</table>
<h2>不合规的代码示例</h2>
<pre>
public static class DeadlockDemo
{
    private static async Task DelayAsync()
    {
        await Task.Delay(1000);
    }

    // 当在GUI 或 ASP.NET 上下文中调用此方法时，将导致死锁。
    public static void Test()
    {
        // 启动延迟。
        var delayTask = DelayAsync();
        // 等待延迟完成。
        delayTask.Wait(); //不合规
    }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public static class DeadlockDemo
{
    private static async Task DelayAsync()
    {
        await Task.Delay(1000);
    }

    public static async Task TestAsync()
    {
        // 启动延迟。
        var delayTask = DelayAsync();
        // 等待延迟完成。
        await delayTask;
    }
}
</pre>
<h2>例外</h2>
<ul>
  <li> 控制台应用程序的主要方法不受此死锁问题的影响，因此被此规则忽略。</li>
  <li> 当在非<code>async</code> 方法中使用 <code>Thread.Sleep</code> 时，也会忽略它。</li>
  <li> 在 <code>Task.Run</code> 或 <code>Task.Factory.StartNew</code> 之后链接的调用将被忽略，因为它们不会遇到这个死锁问题
  </li>
</ul>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">Async/Await - Best Practices in Asynchronous Programming</a> </li>
</ul>

