<p>大多数对 <code>IndexOf</code> 值的检查都是将其与-1比较，因为0在此时也是个有效值。任何以 <code>&gt;0</code> 为条件的检查都会忽略第一个元素，这可能是一个bug。如果只是想检查 <code>string</code>，<code>List</code>，或数组中是否包含某个值，请考虑改用 <code>Contains</code> 方法。</p>
<p>此规则会在对 <code>string</code>，<code>List</code>，或数组检索的 <code>IndexOf</code> 值 <code>&gt;0</code> 时引发问题。</p>
<h2>不合规的代码示例</h2>
<pre>
string color = "blue";
string name = "ishmael";

List&lt;string&gt; strings = new List&lt;string&gt;();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) &gt; 0) // 不合规
{
  // ……
}
if (name.IndexOf("ish") &gt; 0) // 不合规
{
  // ……
}
if (name.IndexOf("ae") &gt; 0) // 不合规
{
  // ……
}
if (Array.IndexOf(stringArray, color) &gt; 0) // 不合规
{
  // ……
}
</pre>
<h2>合规的解决方案</h2>
<pre>
string color = "blue";
string name = "ishmael";

List&lt;string&gt; strings = new List&lt;string&gt; ();
strings.Add(color);
strings.Add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) &gt; -1)
{
  // ……
}
if (name.IndexOf("ish") &gt;= 0)
{
  // ……
}
if (name.Contains("ae"))
{
  // ……
}
if (Array.IndexOf(stringArray, color) &gt;= 0)
{
  // ……
}
</pre>

