<p>如果需要将一个 <code>interface</code> 强制转换为一个具体类（concrete type），那么这意味着所应用的抽象概念（abstractions）有问题，有可能是 <code>interface</code> 中缺少了一些东西。这时不应再强制转换为离散类型（discrete type），而是应该向<code>interface</code>里添加缺失的功能，否则在运行时可能会出现异常。</p>
<h2>不合规的代码示例</h2>
<pre>
public interface IMyInterface
{
  void DoStuff();
}

public class MyClass1 : IMyInterface
{
  public int Data { get { return new Random().Next(); } }

  public void DoStuff()
  {
    // 待办……
  }
}

public static class DowncastExampleProgram
{
  static void EntryPoint(IMyInterface interfaceRef)
  {
    MyClass1 class1 = (MyClass1)interfaceRef;  // 不合规
    int privateData = class1.Data;

    class1 = interfaceRef as MyClass1;  // 不合规
    if (class1 != null)
    {
      // ……
    }
  }
}
</pre>
<h2>例外</h2>
<p>若是转换为 <code>object</code> 则不会引发问题，因为该操作总能成功。</p>
<pre>
static void EntryPoint(IMyInterface interfaceRef)
{
  var o = (object)interfaceRef;
  ...
}
</pre>

