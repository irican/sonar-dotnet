<p>子表达式中的赋值操作很难发现，也因此会降低代码的可读性。理想的情况是子表达式不应该有额外的功能。</p>
<h2>不合规的代码示例</h2>
<pre>
if (string.IsNullOrEmpty(result = str.Substring(index, length))) // 不合规
{
  //...
}
</pre>
<h2>合规的解决方案</h2>
<pre>
var result = str.Substring(index, length);
if (string.IsNullOrEmpty(result))
{
  //...
}
</pre>
<h2>例外</h2>
<p>lambda表达式和委托（delegate）表达式内的赋值是允许的。 </p>
<p>另外，以下的书写方式也是允许的：</p>
<pre>
var a = b = c = 10;
</pre>
<pre>
while ((val = GetNewValue()) &gt; 0)
{
...
}
</pre>
<pre>
private MyClass instance;
public MyClass Instance
{
  get
  {
    return instance ?? (instance = new MyClass());
  }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value </li>
  <li> MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions </li>
  <li> MISRA C:2012, 13.4 - The result of an assignment operator should not be used </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/481.html">MITRE, CWE-481</a> - Assigning instead of Comparing </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/nYFtAg">CERT, EXP45-C.</a> - Do not perform assignments in selection statements </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/1gCTAw">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions
  </li>
</ul>

