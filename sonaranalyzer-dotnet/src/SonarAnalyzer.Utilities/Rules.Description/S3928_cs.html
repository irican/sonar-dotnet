<p><code>ArgumentException</code>，<code>ArgumentNullException</code>，<code>ArgumentOutOfRangeException</code> 和
<code>DuplicateWaitObjectException</code> 类的一些构造函数必须使用一个有效的参数名。此规则会在两种情况下引发问题：</p>
<ul>
  <li> 该参数名与任何现有的参数名不匹配时 </li>
  <li> 调用默认的（无参数）构造函数时 </li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
public void Foo(Bar a, int[] b)
{
  throw new ArgumentException(); // 不合规
  throw new ArgumentException("My error message", "c"); // 不合规
  throw new ArgumentException("My error message", "c", innerException); // 不合规
  throw new ArgumentNullException("c"); // 不合规
  throw new ArgumentNullException("My error message", "c"); // 不合规
  throw new ArgumentOutOfRangeException("c");
  throw new ArgumentOutOfRangeException("c", "My error message"); // 不合规
  throw new ArgumentOutOfRangeException("c", b, "My error message"); // 不合规
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public void Foo(Bar a, Bar b)
{
  throw new ArgumentException("My error message", "a");
  throw new ArgumentException("My error message", "b", innerException);
  throw new ArgumentNullException("a");
  throw new ArgumentNullException(nameOf(a));
  throw new ArgumentNullException("My error message", "a");
  throw new ArgumentOutOfRangeException("b");
  throw new ArgumentOutOfRangeException("b", "My error message");
  throw new ArgumentOutOfRangeException("b", b, "My error message");
}
</pre>
<h2>例外</h2>
<p>如果该参数名不是常量值的话（内联的声明，nameof()或const变量），此规则不会引发问题。</p>

