<p>在编写托管代码（managed code）时，你不必担心内存的分配和释放：垃圾回收器（garbage collector）会处理这些问题。然而出于对效率的考虑，某些对象（如 <code>Bitmap</code>）使用的是非托管内存，比如启用指针算法（pointer arithmetic）。这样的对象可能会占用大量的非托管内存，但托管内存占用却很小。不幸的是，垃圾回收器只能看到这很小的托管内存占用，也就无法及时地回收非托管内存的部分（调用 <code>Bitmap</code>　的终结器）。 </p>
<p>此外，内存并不是唯一需要及时地管理的系统资源：操作系统只能处理一定数量在任意给定时间打开的的文件描述符（例如 <code>FileStream</code>）或socket（例如 <code>WebClient</code>）。因此重要的是在不需要它们时立即调用 <code>Dispose</code> 清理它们，而不是靠垃圾回收器在之后某个不确定的时间来调用这些对象的终结器。</p>
<p>此规则跟踪以下 <code>IDisposable</code> 类型的 <code>private</code> 字段和局部变量，这些类型没有别名，或从未被释放、关闭、返回、与传递给其他方法：</p>
<ul>
  <li> <code>System.IO</code> namespace
    <ul>
      <li> <code>System.IO.FileStream</code> </li>
      <li> <code>System.IO.StreamReader</code> </li>
      <li> <code>System.IO.StreamWriter</code> </li>
    </ul> </li>
  <li> <code>System.Net</code> namespace
    <ul>
      <li> <code>System.Net.WebClient</code> </li>
    </ul> </li>
  <li> <code>System.Net.Sockets</code> namespace
    <ul>
      <li> <code>System.Net.Sockets.Socket</code> </li>
      <li> <code>System.Net.Sockets.TcpClient</code> </li>
      <li> <code>System.Net.Sockets.UdpClient</code> </li>
    </ul> </li>
  <li> <code>System.Drawing</code> namespace
    <ul>
      <li> <code>System.Drawing.Image</code> </li>
      <li> <code>System.Drawing.Bitmap</code> </li>
    </ul> </li>
</ul>
<p>或是要么使用运算符 <code>new</code> 直接实例化，要么使用以下工厂方法（factory methods）中的一个：</p>
<ul>
  <li> <code>System.IO.File.Create()</code> </li>
  <li> <code>System.IO.File.Open()</code> </li>
  <li> <code>System.Drawing.Image.FromFile()</code> </li>
  <li> <code>System.Drawing.Image.FromStream()</code> </li>
</ul>
<p>对private字段和局部变量都是如此。</p>
<h2>不合规的代码示例</h2>
<pre>
public class ResourceHolder
{
  private FileStream fs; // 不合规；Dispose和Close永远不会被调用

  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }

  public void WriteToFile(string path, string text)
  {
    var fs = new FileStream(path, FileMode.Open); // 不合规
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;

  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }

  public void Dispose()
  {
    this.fs.Dispose();
  }

  public void WriteToFile(string path, string text)
  {
    using (var fs = new FileStream(path, FileMode.Open))
    {
      var bytes = Encoding.UTF8.GetBytes(text);
      fs.Write(bytes, 0, bytes.Length);
    }
  }
}
</pre>
<h2>例外</h2>
<p>忽略由方法返回或是传递给其他方法的 <code>IDisposable</code> 变量，正如用其他 <code>IDisposable</code> 初始化的局部 <code>IDisposable</code> 一样。</p>
<pre>
public Stream WriteToFile(string path, string text)
{
  var fs = new FileStream(path, FileMode.Open); // 合规，因为该字段会被返回
  var bytes = Encoding.UTF8.GetBytes(text);
  fs.Write(bytes, 0, bytes.Length);
  return fs;
}

public void ReadFromStream(Stream s)
{
  var sr = new StreamReader(s); // 合规，因为它会关闭底层的流。
  // ……
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup </li>
</ul>

