<p><code>IEquatable&lt;T&gt;</code> 接口中只有一个方法：<code>Equals(&lt;T&gt;)</code>。如果你已经编写了 <code>Equals(T)</code>，那么就没有理由不显式地实现 <code>IEquatable&lt;T&gt;</code>。这样做会允许在调用 <code>IEquatable</code> 时使用它，扩展了你的类的实用性。</p>
<p><strong></strong>注意＊＊：实现了 <code>IEquatable&lt;T&gt;</code> 的类也应为 <code>sealed</code> 型。</p>
<h2>不合规的代码示例</h2>
<pre>
class MyClass  // 不合规
{
  public override bool Equals(object other)
  {
    //……
  }
}
</pre>
<pre>
class MyClass  // 不合规
{
  public bool Equals(MyClass other)
  {
    //……
  }
}
</pre>
<pre>
class MyClass : IEquatable&lt;T&gt;  // 不合规
{
}
</pre>
<h2>合规的解决方案</h2>
<pre>
sealed class MyClass : IEquatable&lt;MyClass&gt;
{
  public override bool Equals(object other)
  {
    return Equals(other as MyClass);
  }

  public bool Equals(MyClass other)
  {
    //……
  }
}
</pre>

