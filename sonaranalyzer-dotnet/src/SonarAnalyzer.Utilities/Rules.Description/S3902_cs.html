<p>使用 <code>Type.Assembly</code> 获取当前程序集对性能几乎是没有损耗的，因为这只是个简单的属性访问。另一方面，<code>Assembly.GetExecutingAssembly()</code> 的损耗可能会达到前者的30倍，因为它会检查调用栈来查找程序集。</p>
<p>注意 <code>Assembly.GetExecutingAssembly()</code> 与 <code>Type.Assembly</code> 不同，前者动态地返回包含当前执行的应用程序的启动对象（the startup object）的程序集。比如，如果从应用程序执行，它会返回应用程序集；但如果从单元测试项目（unit test project）中执行，它可能返回单元测试程序集。而 <code>Type.Assembly</code> 总是返回包含指定类型的程序集。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = Assembly.GetExecutingAssembly(); // 不合规
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Example
{
   public static void Main()
   {
      Assembly assem = typeof(Example).Assembly; // 这里我们使用当前类的类型
      Console.WriteLine("Assembly name: {0}", assem.FullName);
   }
}
</pre>

