<p>单线程环境里，在构造函数中使用 <code>this</code> 是合规的，而且也是推荐的。但在多线程的环境里，这样做可能会将部分构造的（partially-constructed）的对象暴露给其他线程，因此应谨慎操作。</p>
<p>有个经典的例子是一个具有它实例的 <code>static</code> 列表（a static list of its instances）的类，如果构造函数在列表里存储了 <code>this</code>，那么另一个线程可能会在对象完全形成（fully-formed）之前访问它。即使存储 <code>this</code> 是构造函数里的最后一条指令，但如果这个类不是 <code>final</code> 危险仍然存在。在这种情况下，子类的初始化在 <code>this</code> 被公开之前是无法完成的。</p>
<p>当 <code>this</code> 被赋值给构造函数中任意一个全局可见的对象，以及当它被传递构造函数中另一个对象的方法时，此规则都会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Monument
{
  public static readonly List&lt;Monument&gt; ALL_MONUMENTS = new List&lt;Monument&gt;();
  // ……

  public Monument(string location, ...)
  {
    ALL_MONUMENTS.Add(this);  // 不合规，传递给了另一个对象的方法

    this.location = location;
    // ……
  }
}
</pre>
<h2>例外</h2>
<p>此规则忽略将 <code>this</code> 直接赋值给同一个类的 <code>static</code> 字段的实例的情况，因为该情况已由规则S3010涵盖。</p>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/aAD1AQ">CERT, TSM01-J.</a> - Do not let the this reference escape during object
  construction </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/7ABQAg">CERT, TSM03-J.</a> - Do not publish partially initialized objects </li>
</ul>

