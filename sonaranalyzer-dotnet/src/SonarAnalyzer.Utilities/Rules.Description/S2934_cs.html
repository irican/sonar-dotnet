<p>尽管一个 <code>readonly</code> 型的引用类型字段的属性在初始化后仍可以更改，但 <code>readonly</code> 型的值类型字段，例如 <code>struct</code>，它们的属性则不能。 </p>
<p>如果成员是一个 <code>class</code> 或一个 <code>struct</code>，则对该成员属性的赋值可能是不可靠的，有时会起作用，但其他时候就不一定了。</p>
<h2>不合规的代码示例</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T: IPoint
{
  readonly T point;  // 此处可能是一个struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX; //不合规；如果point是一个struct，那么此处是空操作
    Console.WriteLine(point.X);
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : IPoint
{
  readonly T point;  // 此处可能是一个struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX) // 赋值语句已删除
  {
    Console.WriteLine(point.X);
  }
}
</pre>
<p>或者</p>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : class, IPoint
{
  readonly T point;  // 这里可能只是一个class
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX;  // 这里的赋值语句会生效
    Console.WriteLine(point.X);
  }
}
</pre>

