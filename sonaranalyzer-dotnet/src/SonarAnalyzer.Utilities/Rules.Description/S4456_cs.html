<p>由于<code>yield</code> 方法是由编译器重写的(它们变成了延迟计算的状态机)，所以在参数检查期间抛出的任何异常只会在集合迭代时发生。这可能发生在远离错误代码源的地方。</p>
<p>因此，建议将方法分为两部分:处理验证的外部方法(不再延迟)和处理迭代的内部方法(延迟)。</p>
<p>当一个方法抛出从<code>ArgumentException</code> 派生的任何异常，并且包含 <code>yield</code>关键字时，这个规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public static IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate) // Noncompliant
{
    if (source == null) { throw new ArgumentNullException(nameof(source)); }
    if (predicate == null) { throw new ArgumentNullException(nameof(predicate)); }

    foreach (var element in source)
    {
        if (!predicate(element)) { break; }
        yield return element;
    }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public static IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)
{
    if (source == null) { throw new ArgumentNullException(nameof(source)); }
    if (predicate == null) { throw new ArgumentNullException(nameof(predicate)); }
    return TakeWhileIterator&lt;TSource&gt;(source, predicate);
}

private static IEnumerable&lt;TSource&gt; TakeWhileIterator&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)
{
    foreach (TSource element in source)
    {
        if (!predicate(element)) break;
        yield return element;
    }
}
</pre>

