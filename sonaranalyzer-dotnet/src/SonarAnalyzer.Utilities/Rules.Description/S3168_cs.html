<p>返回 <code>void</code> 类型的 <code>async</code> 方法是一个“即用即忘（fire and forget）”的方法，最好留作事件处理方法（event handlers），因为你无法等待它完成执行并做相应的返回，也无法 <code>catch</code> 从该方法中抛出的异常。</p>
<p>有一个非事件处理的 <code>async void</code> 方法意味着你的程序可能会由于时间的问题时而工作时而不能。所以相反地，<code>async</code> 方法应该返回 <code>Task</code>。</p>
<p>当非事件处理方法（non-event handler methods）既是 <code>async</code> 的又是 <code>void</code> 的时，此规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
class HttpPrinter
{
  private string content;

  public async void CallNetwork(string url) //不合规
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)  // 如果web请求是在1秒以内则可以正确运行，否则content会为null
  {
    CallNetwork(url);
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
class HttpPrinter
{
  private string content;

  public async Task CallNetwork(string url)
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)
  {
    await CallNetwork(url); // &lt;----- 请求在此处做了更改。如果不加await会触发warning CS4014
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>
<h2>例外</h2>
<p>事件处理方法会被忽略。即包含两个参数，第一个参数匹配 <code>object sender</code>，第二个参数继承或它本身是 <code>EventArgs</code> 的方法。</p>

