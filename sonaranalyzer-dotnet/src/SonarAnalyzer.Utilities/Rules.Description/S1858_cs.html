<p>对一个已经是字符串的对象调用将其字符串化表示的方法是在浪费击键（a waste of keystrokes）。类似地，在编译器会隐式调用的情况下再显式调用 <code>ToString()</code> 也会造成毫无必要的代码膨胀（code-bloat）。</p>
<p>此规则会在以下调用 <code>ToString()</code> 的场合引发问题：</p>
<ul>
  <li> 对 <code>string</code> 使用</li>
  <li> 对一个非 <code>string</code> 类型的操作数使用以进行字符串连接 </li>
  <li> 对 <code>string.Format</code> 的参数使用</li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
var s = "foo";
var t = "fee fie foe " + s.ToString();  // 不合规
var someObject = new object();
var u = "" + someObject.ToString(); // 不合规
var v = string.Format("{0}", someObject.ToString()); // 不合规
</pre>
<h2>合规的解决方案</h2>
<pre>
var s = "foo";
var t = "fee fie foe " + s;
var someObject = new object();
var u = "" + someObject;
var v = string.Format("{0}", someObject);
</pre>
<h2>例外</h2>
<p>此规则忽略对值类型对象的使用，因为不调用 <code>ToString()</code> 会发生自动封装（automatic boxing）。</p>
<pre>
var v = string.Format("{0}", 1.ToString());
</pre>

