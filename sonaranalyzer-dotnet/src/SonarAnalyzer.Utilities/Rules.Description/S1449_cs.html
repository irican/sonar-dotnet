<p><code>string.ToLower()</code>，<code>ToUpper</code>，<code>IndexOf</code>，<code>LastIndexOf</code> 以及 <code>Compare</code> 都是地区性相关（culture-dependent）的，正如对 <code>ToString</code> 的调用（浮点数以及与 <code>DateTime</code> 相关的）。幸运的是，所有这些方法都有变量来接受特定的参数，这些参数可指定区域性或要使用的格式化器（formatter）。如果调用这些方法时不使用这些参数，系统默认的地区就会被启用，使用国际字符时可能就会出现问题。</p>
<p><code>string.CompareTo()</code> 也是特定于地区性的，但它没有使用地区性信息的重载（but has no overload that takes a culture information）。所以最好换用 <code>CompareOrdinal</code>，或使用 <code>Compare</code> 并指明地区。</p>
<p>在系统的“本地”环境下不指明地区进行调用或许是可行的，但对于使用不同编码的客户来说，此次调用可能会失败，并且极难诊断其原因。这样的bug在需要修复它们时几乎（甚至是完全）是不可能复现的.</p>
<h2>不合规的代码示例</h2>
<pre>
var lowered = someString.ToLower(); //不合规
</pre>
<h2>合规的解决方案</h2>
<pre>
var lowered = someString.ToLower(CultureInfo.InvariantCulture);
</pre>
<p>或者</p>
<pre>
var lowered = someString.ToLowerInvariant();
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/EwAiAg">CERT, STR02-J.</a> - Specify an appropriate locale when comparing
  locale-dependent data </li>
</ul>

