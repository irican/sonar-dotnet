<p>检查对象的类型时有几个选项：</p>
<ul>
	<li> 如果其类型在编译时已知可使用 <code>expr is SomeType</code> 或 <code>expr.GetType() == typeof(SomeType)</code>， </li>
	<li> 如果其类型是在运行时计算的则可使用 <code>typeInstance.IsInstanceOfType(expr)</code>。 </li>
</ul>
<p>如果需要比较运行时计算的 <code>Type</code>：</p>
<ul>
	<li> <code>typeInstance1.IsAssignableFrom(typeInstance2)</code>. </li>
</ul>
<p>根据类型是由 <code>GetType()</code> 返回或调用 <code>typeof()</code> 返回，可以简化 <code>IsAssignableFrom()</code> 和<code>IsInstanceOfType()</code>。类似地，如果类型 <code>sealed</code> 的，则可以将使用 <code>==</code> 的类型比较转换为一次 <code>is</code> 调用。简化调用也不需要进行 <code>null</code> 的检查，因为 <code>is</code> <code>IsInstanceOfType</code> 都已经执行了null值检查。</p>
<p>最后，使用最简洁的语言结构进行类型检查可以使代码更加易读，所以</p>
<ul>
	<li> <code>expr as T != null</code> 检查应简化为 <code>expr is T</code>，并且 </li>
	<li> 当 <code>expr</code> 为 <code>T</code> 类型时，<code>expr is T</code> 应简化为 <code>expr != null</code>。 </li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
class Fruit { }
sealed class Apple : Fruit { }

class Program
{
  static void Main()
  {
    var apple = new Apple();
    var b = apple != null &amp;&amp; apple.GetType() == typeof (Apple); // 不合规
    b = typeof(Apple).IsInstanceOfType(apple); // 不合规
    if (apple != null)
    {
      b = typeof(Apple).IsAssignableFrom(apple.GetType()); // 不合规
    }
    var appleType = typeof (Apple);
    if (apple != null)
    {
      b = appleType.IsAssignableFrom(apple.GetType()); // 不合规
    }

    Fruit f = apple;
    if (f as Apple != null) // 不合规
    {
    }
    if (apple is Apple) // 不合规
    {
    }
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
class Fruit { }
sealed class Apple : Fruit { }

class Program
{
  static void Main()
  {
    var apple = new Apple();
    var b = apple is Apple;
    b = apple is Apple;
    b = apple is Apple;
    var appleType = typeof(Apple);
    b = appleType.IsInstanceOfType(apple);

    Fruit f = apple;
    if (f is Apple)
    {
    }
    if (apple != null)
    {
    }
  }
}
</pre>
<h2>例外</h2>
<p>对 <code>Nullable&lt;T&gt;</code> 类型的对象调用 <code>GetType</code> 会返回基础的泛型类型参数<code>T</code>，因此使用 <code>typeof(Nullable&lt;T&gt;)</code> 的比较无法简化为使用 <code>is</code> 运算符的，因为这样在 <code>T</code> 与 <code>T?</code> 间不起作用。</p>
<pre>
int? i = 42;
bool condition = i.GetType() == typeof(int?); // false；
condition = i is int?; // true
</pre>
<p>如果 <code>is</code> 运算符的任一操作数是值类型，那么 <code>expr is T</code> 表达式不会报告任何问题。这种情况由CS0183或CS0184报告。</p>

