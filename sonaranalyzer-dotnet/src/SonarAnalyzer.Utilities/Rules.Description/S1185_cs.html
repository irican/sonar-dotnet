<p>重写方法时如果只是调用了基类的方法而没有执行其他的操作是没有意义的，还会对人造成误导。只有 <code>sealed</code> 类的方法在重写时可以这么做，因为它能将父类的行为锁起来，防止其他类将其重写。另外，此规则忽略对 <code>Equals</code> 和 <code>GetHashCode</code>的重写。</p>
<p>注意：添加或删掉空的重写方法都很危险，因为它们可能正在破坏已做出的修改（as they might be breaking changesbreak changes）。</p>
<h2>不合规的代码示例</h2>
<pre>
public override void Method() // 不合规
{
  base.Method();
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public override void Method()
{
  //实现其他的功能
}
</pre>
<h2>例外</h2>
<p>如果在重写的关系层次中任何一级中出现了特性（attribute），那么被重写的成员不适用于此规则：</p>
<pre>
public class Base
{
  [Required]
  public virtual string Name { get; set; }
}

public class Derived : Base
{
  public override string Name
  {
    get
    {
      return base.Name;
    }
    set
    {
      base.Name = value;
    }
  }
}
</pre>
<p>如果重写的方法有注释说明，也会被此规则忽略：</p>
<pre>
public class Foo : Bar
{
    /// &lt;summary&gt;
    /// 保留此方法以保证后续使用的兼容性。
    /// &lt;/summary&gt;
    public override void DoSomething()
    {
        base.DoSomething();
    }
}
</pre>

