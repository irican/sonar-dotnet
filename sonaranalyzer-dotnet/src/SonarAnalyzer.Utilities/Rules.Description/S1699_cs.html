<p>在实例化一个重写过方法的子类时，从构造函数里调用可重写的方法可能会导致失败，或是出现异常的行为。</p>
<p>例如：</p>
<ul>
  <li> 子类的构造函数通过调用父类的构造函数开始运行。 </li>
  <li> 父类构造函数调用某个在子类里被重写过的方法。 </li>
  <li> 如果子类方法的行为依赖于在子类构造函数中初始化的字段，则可能导致意外的行为（如 <code>NullReferenceException<code>），因为这些字段尚未初始化。</li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
public class Parent
{
  public Parent()
  {
    DoSomething();  // 不合规
  }

  public virtual void DoSomething() // 可重写
  {
    ...
  }
}

public class Child : Parent
{
  private string foo;

  public Child(string foo) // 会调用Parent构造函数中的 DoSomething()，由于foo尚未初始化，这里会触发NullReferenceException
  {
    this.foo = foo;
  }

  public override void DoSomething()
  {
    Console.WriteLine(this.foo.Length);
  }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/MYYbAQ">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/TQBi">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or
  destructors </li>
</ul>

