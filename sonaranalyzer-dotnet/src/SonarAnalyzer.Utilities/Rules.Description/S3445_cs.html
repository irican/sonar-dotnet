<p>当一个异常再次抛出时，你应该调用 <code>throw;</code> 而不是 <code>throw exc;</code>，因为堆栈的跟踪信息（stack trace）会被后者重置，这会增加调试的难度。</p>
<h2>不合规的代码示例</h2>
<pre>
try
{}
catch(ExceptionType1 exc)
{
  Console.WriteLine(exc);
  throw exc; // 不合规，堆栈跟踪信息被重置
}
catch (ExceptionType2 exc)
{
  throw new Exception("My custom message", exc);  // 合规，保留了堆栈信息
}
</pre>
<h2>合规的解决方案</h2>
<pre>
try
{}
catch(ExceptionType1 exc)
{
  Console.WriteLine(exc);
  throw;
}
catch (ExceptionType2 exc)
{
  throw new Exception("My custom message", exc);
}
</pre>

