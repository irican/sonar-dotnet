<p>在重写的方法里使用 <code>base</code> 调用通常是个好主意，但在 <code>GetHashCode</code> 和 <code>Equals</code> 中，这却并不适用于那些直接扩展 <code>object</code> 的类。因为这两个方法是基于对象的引用的，这意味着使用这两个 <code>base</code> 方法的两个 <code>objects</code> 永远不会相等或是有相同的hash值。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode() ^ base.GetHashCode(); //不合规
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode();
  }
}
</pre>
<h2>例外</h2>
<p>此规则不会报告在保护条件（guard conditions）中用于检查引用是否相等的基调用。</p>
<pre>
public class Point
{
  public override bool Equals(object obj)
  {
    if (base.Equals(obj)) // 合规，但此处可以替换为object.ReferenceEquals(obj, this)，并且替换后更易懂
    {
      return true;
    }
    ...
  }
}
</pre>

