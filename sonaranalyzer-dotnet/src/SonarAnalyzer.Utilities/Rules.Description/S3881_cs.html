<p><code>IDisposable</code> 接口是一种释放非托管资源的机制，如果不做正确的实现，此机制可能会导致资源泄露或更严重的错误。</p>
<p>如不遵守由微软定义的推荐清理模式此规则会引发问题。具体示例请参见 <strong>合规的解决方案</strong> 部分。</p>
<p>满足此规则的以下条件将使潜在的派生类能够正确处理类的成员：</p>
<ul>
  <li> <code>sealed</code> 类不予检查。 </li>
  <li> 如果基类实现了 <code>IDisposable</code>，则你的类的接口列表中不应再包含 <code>IDisposable</code>。这种情况建议
  重写基类的 <code>protected virtual void Dispose(bool)</code> 方法，或重写此方法的等效方法。 </li>
  <li> 类中不应显式地实现 <code>IDisposable</code> 方法，例如 <code>Dispose()</code> 方法应为public型。 </li>
  <li> 类中应包含 <code>protected virtual void Dispose(bool)</code> 方法。此方法允许派生类正确处理该类的资源。 </li>
  <li> <code>Dispose()</code> 方法的内容应是对 <code>Dispose(true)</code> 的调用，而后有 <code>GC.SuppressFinalize(this)</code>。</li>
  <li> 如果类有终结器，即析构函数，则它主体中的唯一代码应是对 <code>Dispose(false)</code> 的单词调用。</li>
  <li> 如果类继承自一个已实现了 <code>IDisposable</code> 的类，则该类必须分别从自己实现的 <code>Dispose</code> 或 <code>Dispose(bool)</code>
  中调用基类的 <code>Dispose</code> 或 <code>Dispose(bool)</code> 方法。这样就确保了来自基类的所有资源能够正确地释放。</li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
public class Foo1 : IDisposable // 不合规－应在Foo上提供Dispose(bool)的protected型的可重写实现，或将该类型标记为sealed
{
    public void Dispose() // 不合规－应只包含Dispose(true)的调用，而后进行GC.SuppressFinalize(this)
    {
        // 清理
    }
}

public class Foo2 : IDisposable
{
    void IDisposable.Dispose() // 不合规－Dispose()应为public型
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    public virtual void Dispose() // 不合规－Dispose()应为sealed型
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}

public class Foo3 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        // 清理
    }

    ~Foo3() // 不合规－修改Foo.~Foo()，使其调用Dispose(false)，然后返回
    {
        // 清理
    }
}{code}
</pre>
<h2>合规的解决方案</h2>
<pre>
// Sealed类
public sealed class Foo1 : IDisposable
{
    public void Dispose()
    {
        // 清理
    }
}

// 简单实现
public class Foo2 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        // 清理
    }
}

// 带finalizer的实现
public class Foo3 : IDisposable
{
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        // 清理
    }

    ~Foo3()
    {
        Dispose(false);
    }
}

// 已实现IDisposable的基类
public class Foo4 : DisposableBase
{
    protected override void Dispose(bool disposing)
    {
        // 清理
        // 别忘了调用基类
        base.Dispose(disposing);
    }
}
</pre>
<h2>请参阅</h2>
<p>参考</p>
<ul>
  <li> <a href="https://msdn.microsoft.com/en-us/library/498928w2.aspx">MSDN</a> for complete documentation on the dispose pattern. </li>
  <li> <a href="http://blog.stephencleary.com/2009/08/how-to-implement-idisposable-and.html">Stephen Cleary</a> for excellent Q&amp;A about
  IDisposable </li>
  <li> <a href="http://pragmateek.com/c-scope-your-global-state-changes-with-idisposable-and-the-using-statement/">Pragma Geek</a> for additional
  usages of IDisposable, beyond releasing resources. </li>
  <li> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.idisposable?view=netframework-4.7">IDisposable documentation</a> </li>
</ul>

