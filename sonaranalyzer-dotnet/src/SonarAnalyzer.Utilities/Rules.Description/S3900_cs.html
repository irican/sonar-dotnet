<p>public方法可以在任何地方被调用，这意味着你应该你应该验证一下参数是否处在预期的约束范围内。通常来说，<code>null</code> 值检查就是一种推荐的防御性编程措施（defensive programming）</p>
<p>当public方法的某个参数没有在解引用（dereference）前进行 <code>null</code> 值检查时，此规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public class MyClass
{
    private MyOtherClass other;

    public void Foo(MyOtherClass other)
    {
        this.other = other; // 合规：other没有被解引用
    }

    public void Bar(MyOtherClass other)
    {
        this.other = other.Clone(); // 不合规
    }
	
	protected void FooBar(MyOtherClass other)
    {
        this.other = other.Clone(); // 不合规
    }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class MyClass
{
    private MyOtherClass other;

    public void Foo(MyOtherClass other)
    {
        this.other = other;
    }

    public void Bar(MyOtherClass other)
    {
        if (other != null)
        {
            this.other = other.Clone();
        }
    }
	
	protected void FooBar(MyOtherClass other)
    {
        if (other != null)
        {
            this.other = other.Clone();
        }
    }
}
</pre>
<h2>例外</h2>
<p>若要创建自定义的null值检查方法，请声明名为 <code>ValidatedNotNullAttribute</code> 的特性，并在你的方法声明中用它标记待检查的参数：</p>
<pre>
using System;

public sealed class ValidatedNotNullAttribute : Attribute { }

public static class Guard
{
    public static void NotNull&lt;T&gt;([ValidatedNotNullAttribute] this T value, string name) where T : class
    {
        if (value == null)
            throw new ArgumentNullException(name);
    }
}

public static class Utils
{
    public static string ToUpper(string value)
    {
        Guard.NotNull(value, nameof(value));
        if (value == null)
        {
            return value.ToString();
        }
        return value.ToUpper(); // 合规
    }
}
</pre>

