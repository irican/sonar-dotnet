<p>将一个整数移动0位等同于什么都没做，并且只会让维护人员觉得代码混乱。</p>
<p>如果第一个操作数是一个 <code>int</code> 或是 <code>uint</code>（32位），则移位计数由第二个操作数的低位5位给出。也就是说，实际的移位位数是0到31位。</p>
<p>注意少于32位的整数（例如 <code>short</code>， <code>ushort</code>……）在移位操作前会隐式地转为 <code>int</code> 型，因此针对 <code>int</code>／<code>uint</code> 的规则同样适用。</p>
<p>如果第一个操作数是 <code>long</code> 或 <code>ulong</code> 型（64位），则移位计数由第二个操作数的低位6位给出。也就是说，实际的移位位数是0到63位。</p>
<h2>不合规的代码示例</h2>
<pre>
public void Main()
{
    short s = 1;
    short shortShift1 = (short)(s &lt;&lt; 0); //不合规
    short shortShift1 = (short)(s &lt;&lt; 16); // 合规，因为short会强制转换为int（16在0和31之间）
    short shortShift3 = (short)(s &lt;&lt; 32); //不合规，相当于移动1位

    int i = 1;
    int intShift1 = i &lt;&lt; 0; //不合规
    int intShift2 = i &lt;&lt; 32; //不合规，相当于移动1位

    long lg = 1;
    long longShift1 = lg &lt;&lt; 0; //不合规
    long longShift2 = lg &lt;&lt; 64; //不合规，相当于移动1位
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public void Main()
{
    short s = 1;
    short shortShift1 = s;
    short shortShift1 = (short)(s &lt;&lt; 16);
    short shortShift3 = (short)(s &lt;&lt; 1);

    int i = 1;
    var intShift1 = i;
    var intShift2 = i &lt;&lt; 1;

    long lg = 1;
    var longShift1 = lg;
    var longShift2 = lg &lt;&lt; 1;
}
</pre>
<h2>例外</h2>
<p>零移位操作如果明显地是出于以下表面的原因时，此规则不会引发问题：</p>
<ul>
  <li> 当移位的值为常量时。 </li>
  <li> 在上下行有类似的移位操作时，如： </li>
</ul>
<pre>
bytes[loc+0] = (byte)(value &gt;&gt; 8);
bytes[loc+1] = (byte)(value &gt;&gt; 0);
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/left-shift-operator">MSDN Left-shift operator</a> </li>
  <li> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/right-shift-operator">MSDN Right-shift operator</a> </li>
</ul>

