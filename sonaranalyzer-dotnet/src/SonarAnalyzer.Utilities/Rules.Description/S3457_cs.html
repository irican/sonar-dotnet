<p>由于复合格式字符串（composite format strings）是在运行时解释而不是由编译器进行验证，因此它们可能导致意外的行为或在运行时产生错误。该规则静态地验证在调用以下方法时复合格式字符串的良好行为（good behavior）：<code>String.Format</code>，<code>StringBuilder.AppendFormat</code>，<code>Console.Write</code>，<code>Console.WriteLine</code>，<code>TextWriter.Write</code>，<code>TextWriter.WriteLine</code>，<code>Debug.WriteLine(String, Object[])</code>，<code>Trace.TraceError(String, Object[])</code>，<code>Trace.TraceInformation(String, Object[])</code>，<code>Trace.TraceWarning(String, Object[])</code> 和 <code>TraceSource.TraceInformation(String, Object[])</code>。</p>
<h2>不合规的代码示例</h2>
<pre>
s = string.Format("{0}", arg0, arg1); // 不合规，声明了arg1但并没有使用
s = string.Format("{0} {2}", arg0, arg1, arg2); // 不合规，缺少索引为1的项因此不会使用到arg1
s = string.Format("foo"); // 不合规，这里没必要使用string.Format
</pre>
<h2>合规的解决方案</h2>
<pre>
s = string.Format("{0}", arg0);
s = string.Format("{0} {1}", arg0, arg2);
s = "foo";
</pre>
<h2>例外</h2>
<ul>
  <li> 如果格式字符串不是 <code>const</code> 就不会引发问题。</li>
</ul>
<pre>
var pattern = "{0} {1} {2}";
var res = string.Format(pattern, 1, 2); // 合规，无法识别非常量的字符串
</pre>
<ul>
  <li> 如果参数不是内联创建的数组（inline creation array）就不会引发问题。 </li>
</ul>
<pre>
var array = new int[] {};
var res = string.Format("{0} {1}", array); // 合规，不知道数组的大小
</pre>
<ul>
  <li> 此规则对格式说明符（在 <code>:</code> 后定义）是否有效不做检查。</li>
</ul>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/wQA1">CERT, FIO47-C.</a> - Use valid format strings </li>
</ul>

