<p>泛型类型中的静态字段在不同的封闭构造类型（closed constructed types）的实例中并不共享，因此即使 <code>instances</code> 似乎在所有 <code>LengthLimitedSingletonCollection&lt;&gt;</code> 泛型类中都是共享的，但 <code>LengthLimitedSingletonCollection&lt;int&gt;.instances</code> 和 <code>LengthLimitedSingletonCollection&lt;string&gt;.instances</code> 指向的是不同的对象。</p>
<p>如果你需要让有不同泛型参数的实例来共享一个静态字段，请定义一个非泛型的基类来存储这个静态成员，然后让泛型类型继承自这个基类。</p>
<h2>不合规的代码示例</h2>
<pre>
public class LengthLimitedSingletonCollection&lt;T&gt; where T : new()
{
  protected const int MaxAllowedLength = 5;
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // 不合规

  public static T GetInstance()
  {
    object instance;

    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count &gt;= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class SingletonCollectionBase
{
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;();
}

public class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()
{
  protected const int MaxAllowedLength = 5;

  public static T GetInstance()
  {
    object instance;

    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count &gt;= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>
<h2>例外</h2>
<p>如果静态字段或属性使用了类型参数，则可以假定开发人员是了解该静态字段不会在封闭构造的类型中共享的。</p>
<pre>
public class Cache&lt;T&gt;
{
   private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // 合规
}
</pre>

