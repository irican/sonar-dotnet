<p><code>object.Equals()</code> 的重写可以通过先检查 <code>this</code> 和参数的引用是否相等来进行优化。这项检查可以通过调用 <code>object.ReferenceEquals()</code> 或 <code>base.Equals()</code> 来实现，在后者中 <code>base</code> 就是 <code>object</code>。然而，使用 <code>base.Equals()</code> 对维护是有危害的，因为当你直接扩展了 <code>Object</code> 并且成功时，如果你引入重写了 <code>Equals</code> 的新基类，它会突然停止运行。</p>
<p>如果使用了 <code>base.Equals()</code> 但 <code>base</code> 不是 <code>object</code> 时，此规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (base.Equals(other)) // 好的，base在这里是object
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (base.Equals(other))  // 不合规
    {
      return true;
    }

    return this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))  // base.Equals在这里可行，但object.ReferenceEquals更好
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))
    {
      return true;
    }

    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>

