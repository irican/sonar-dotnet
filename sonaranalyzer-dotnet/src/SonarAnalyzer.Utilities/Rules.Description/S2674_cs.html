<p>你不能假定所有给定的流读取调用（stream reading call）都能以请求的字节数把要传给方法的 <code>byte[]</code> 填满。相反地，你必须对这个读方法（read method）的返回值进行检查，看看到底读取了多少字节。如果不这么做，你就会引入一个有害且很难再现的bug。</p>
<p>此规则会在调用了 <code>Stream.Read</code> 或 <code>Stream.ReadAsync</code> 方法而不对其返回值进行检查时引发问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var result = new byte[stream.Length];
    stream.Read(result, 0, (int)stream.Length); // 不合规
    // ……对得到的结果进行处理
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var buffer = new byte[1024];
    using (var ms = new MemoryStream())
    {
        int read;
        while ((read = stream.Read(buffer, 0, buffer.Length)) &gt; 0)
        {
            ms.Write(buffer, 0, read);
        }
        // ……对ms进行处理
    }
  }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/XACSAQ">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an
  array </li>
</ul>

