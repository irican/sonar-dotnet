<p>抽象类的用途就是提供一些可继承的行为，同时定义一些必须由子类实现的方法。</p>
<p>一个 <code>class</code> 没有抽象类方法却被定义为 <code>abstract</code> 只是为了不被实例化，应该将其转变为一个具体的（concrete）<code>class</code>（即删除关键字 <code>abstract</code> ），并为其实现一个 <code>protected</code> 的构造函数。</p>
<p>一个 <code>class</code> 只有 <code>abstract</code> 方法而没有可继承的行为时，应该将其转换为 <code>interface</code>。</p>
<h2>不合规的代码示例</h2>
<pre>
public abstract class Animal //不合规；应该将其改为接口
{
  abstract void Move();
  abstract void Feed();
}

public abstract class Color //不合规；应该改写为具体类，并实现一个protected型的构造函数
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  public int GetRed()
  {
    return red;
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public interface Animal
{
  void Move();
  void Feed();
}

public class Color
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  protected Color()
  {}

  public int GetRed()
  {
    return red;
  }
}

public abstract class Lamp
{
  private bool switchLamp = false;

  public abstract void Glow();

  public void FlipSwitch()
  {
    switchLamp = !switchLamp;
    if (switchLamp)
    {
      Glow();
    }
  }
}
</pre>

