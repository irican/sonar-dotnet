<p>控制权限是安全敏感的。它在过去导致了以下漏洞：</p>
<ul>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12999">CVE-2018-12999</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10285">CVE-2018-10285</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7455">CVE-2017-7455</a> </li>
</ul>
<p>攻击者只能破坏他们所能访问的东西。因此，限制他们的访问是防止他们造成破坏的好方法，但必须正确地做。</p>
<p>此规则标记控制对资源和操作的访问或配置此访问的代码。目标是指导安全代码审查。</p>
<h2>检查是否有下列问题：</h2>
<ul>
  <li> 至少有一个被访问的操作或资源是安全敏感的。</li>
  <li> 没有适当的访问控制，或者它不能覆盖所有敏感的操作和资源。</li>
  <li> 用户拥有他们不需要的权限。</li>
  <li> 访问控制基于用户输入或其他一些不安全数据。</li>
  <li> 权限很难删除或需要很长时间才能更新。</li>
</ul>
<p>如果对其中任何一个问题的回答是肯定的，那么就有风险。</p>
<h2>推荐的安全编码实践</h2>
<p>第一步是将所有敏感操作限制为经过身份验证的用户。</p>
<p>每个用户应该拥有尽可能低的特权。访问控制粒度应该匹配每个资源或操作的敏感性。它越敏感，人们接触它的机会就越少。</p>
<p>不要将访问控制基于用户输入或可能被篡改的值。例如，开发人员不应该从HTTP cookie读取用户的权限，因为它可以在客户端修改。</p>
<p>检查对每个操作和资源的访问是否受到了适当的限制。</p>
<p>允许管理员在必要时快速删除权限。这使它们能够减少攻击者在发生攻击时访问您的系统的时间。</p>
<p>记录和监视被拒绝的访问请求，因为它们可能揭示攻击。</p>
<h2>可疑的代码示例</h2>
<pre>
using System.Threading;
using System.Security.Permissions;
using System.Security.Principal;
using System.IdentityModel.Tokens;

class SecurityPrincipalDemo
{
    class MyIdentity : IIdentity // 可疑的，应该审查自定义IIdentity的实现
    {
        // ...
    }

    class MyPrincipal : IPrincipal // 可疑的，应该审查自定义IPrincipal的实现
    {
        // ...
    }
    [System.Security.Permissions.PrincipalPermission(SecurityAction.Demand, Role = "Administrators")] // 可疑的。应该审查此属性强制执行的访问限制。
    static void CheckAdministrator()
    {
        WindowsIdentity MyIdentity = WindowsIdentity.GetCurrent(); // 可疑的
        HttpContext.User = ...; // 可疑的: 检查 System.Web HttpContext.User 的所有引用（set 和 get）
        AppDomain domain = AppDomain.CurrentDomain;
        domain.SetPrincipalPolicy(PrincipalPolicy.WindowsPrincipal); // 可疑的
        MyIdentity identity = new MyIdentity(); // 可疑的
        MyPrincipal MyPrincipal = new MyPrincipal(MyIdentity); // 可疑的
        Thread.CurrentPrincipal = MyPrincipal; // 可疑的
        domain.SetThreadPrincipal(MyPrincipal); // 可疑的

        // 应该审查 PrincipalPermission 权限的所有实例化。
        PrincipalPermission principalPerm = new PrincipalPermission(null, "Administrators"); // 可疑的
        principalPerm.Demand();

        SecurityTokenHandler handler = ...;
        // 可疑的: 这创建了一个标识。
        ReadOnlyCollection&lt;ClaimsIdentity&gt; identities = handler.ValidateToken(…);
    }

     // 可疑的: 检查此函数是如何使用标识和主体的。
    void modifyPrincipal(MyIdentity identity, MyPrincipal principal)
    {
        // ...
    }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control">OWASP Top 10 2017 Category A5</a> - Broken Access Control </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat3">SANS Top 25</a> - Porous Defenses </li>
</ul>

