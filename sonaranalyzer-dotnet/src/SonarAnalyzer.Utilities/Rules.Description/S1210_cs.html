<p>当你在某个类中实现 <code>IComparable</code> 或 <code>IComparable&lt;T&gt;</code> 时，你还应该重写 <code>Equals(object)</code> 方法并重载比较运算符（<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>）。 这是因为CLR（公共语言运行库）无法自动地从 <code>Equals(object)</code> 和基本的比较运算符（base comparison operator implementations）来调用你实现的 <code>CompareTo</code>。另外，将 <code>GetHashCode</code> 与 <code>Equals</code>一齐重写是个好习惯。</p>
<p>当某个类实现了 <code>IComparable</code> 而没有重写 <code>Equals(object)</code> 与比较运算符时，此规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Foo: IComparable  // 不合规
{
  public int CompareTo(object obj) { /* …… */ }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Foo: IComparable
{
  public int CompareTo(object obj) { /* …… */ }
  public override bool Equals(object obj)
  {
    var other = obj as Foo;
    if (object.ReferenceEquals(other, null))
    {
      return false;
    }
    return this.CompareTo(other) == 0;
  }
  public int GetHashCode() { /* …… */ }
  public static bool operator == (Foo left, Foo right)
  {
    if (object.ReferenceEquals(left, null))
    {
      return object.ReferenceEquals(right, null);
    }
    return left.Equals(right);
  }
  public static bool operator &gt; (Foo left, Foo right)
  {
    return Compare(left, right) &gt; 0;
  }
  public static bool operator &lt; (Foo left, Foo right)
  {
    return Compare(left, right) &lt; 0;
  }
  public static bool operator != (Foo left, Foo right)
  {
    return !(left == right);
  }
}
</pre>

