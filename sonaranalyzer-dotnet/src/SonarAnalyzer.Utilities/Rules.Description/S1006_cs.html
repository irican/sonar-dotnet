<p>默认实参是由对象的静态类型（static type）决定的，如果重写的方法的默认实参与原方法的不同，那么通过基类的对象与通过派生对象调用方法所得到的值是不同的，这样可能会出现与开发者意图相悖的结果。</p>
<p>默认实参的值在显式接口的实现中是不起作用的，因为该对象的静态类型总是这个实现了的接口。因此，此时指定默认值是没有意义且令人困惑的。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Base
{
  public virtual void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Derived : Base
{
  public override void Write(int i = 5) // 不合规
  {
    Console.WriteLine(i);
  }
}

public class Program
{
  public static void Main()
  {
    var derived = new Derived();
    derived.Write(); // 输出5
    Print(derived);  // 输出42，但这是预期的结果吗？
  }
  private void Print(Base item)
  {
    item.Write();
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Base
{
  public virtual void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Derived : Base
{
  public override void Write(int i = 42)
  {
    Console.WriteLine(i);
  }
}

public class Program
{
  public static void Main()
  {
    var derived = new Derived();
    derived.Write(); // 输出42
    Print(derived);  // 输出42
  }
  private void Print(Base item)
  {
    item.Write();
  }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> MISRA C++:2008, 8-3-1 - Parameters in a overriding virtual function shall either use the same default arguments as the function they override,
  or else shall not specify any default arguments. </li>
</ul>

