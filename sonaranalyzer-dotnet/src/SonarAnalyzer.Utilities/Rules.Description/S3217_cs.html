<p> <code>foreach</code> 是在泛型之前引入C#语言的，目的是能更容易地处理当时可用的非泛型集合，例如 <code>ArrayList</code>。 <code>foreach</code> 语句允许你将 <code>Object</code> 的集合中的元素向下强制转换为（downcast）其他任意类型。问题在于，为了完成这一转换，<code>foreach</code> 会默认地执行 <code>explicit</code> 的类型转换，在运行时这样可能会产生 <code>InvalidCastException</code>。</p>
<p>在泛型集合或数组上迭代的C#代码不应依赖 <code>foreach</code> 语句无声的 <code>explicit</code> 类型转换机制。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Fruit { }
public class Orange : Fruit { }
public class Apple : Fruit { }

class MyTest
{
  public void Test()
  {
    var fruitBasket = new List&lt;Fruit&gt;();
    fruitBasket.Add(new Orange());
    fruitBasket.Add(new Orange());
    // fruitBasket.Add(new Apple());  // 删去该行的注释符会导致下方的两个foreach语句都抛出InvalidCastException

    foreach (Fruit fruit in fruitBasket)
    {
      var orange = (Orange)fruit; // 这个“显式的”类型转换藏在下方的foreach循环里 
      ...
    }

    foreach (Orange orange in fruitBasket) // 不合规
    {
      ...
    }
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
var fruitBasket = new List&lt;Orange&gt;();
fruitBasket.Add(new Orange());
fruitBasket.Add(new Orange());
// fruitBasket.Add(new Apple());  // 删去该行的注释符会导致无法编译

foreach (Orange orange in fruitBasket)
{
  ...
}
</pre>
<p>或者</p>
<pre>
var fruitBasket = new List&lt;Fruit&gt;();
fruitBasket.Add(new Orange());
fruitBasket.Add(new Orange());
fruitBasket.Add(new Apple());

foreach (Orange orange in fruitBasket.OfType&lt;Orange&gt;())
{
  ...
}
</pre>
<h2>例外</h2>
<p>此规则忽略 <code>object</code> 的集合上的迭代。这也包括使用 <code>ArrayList</code> 的旧代码。此外，调用用户定义的类型转换时，此规则不会报告。 </p>

