<p>由于复合的格式化字符串是在运行时解释，而不是由编译器验证的，因此他们可能会导致意外的行为或运行时的错误。此规则静态地对复合的格式化字符串的使用是否正确进行验证，具体来说是在调用以下方法时：<code>String.Format</code>，<code>StringBuilder.AppendFormat</code>，<code>Console.Write</code>，<code>Console.WriteLine</code>，<code>TextWriter.Write</code>，<code>TextWriter.WriteLine</code>，<code>Debug.WriteLine(String, Object[])</code>，<code>Trace.TraceError(String, Object[])</code>，<code>Trace.TraceInformation(String, Object[])</code>，<code>Trace.TraceWarning(String, Object[])</code> 以及 <code>TraceSource.TraceInformation(String, Object[])</code>。 </p>
<h2>不合规的代码示例</h2>
<pre>
s = string.Format("[0}", arg0);
s = string.Format("{{0}", arg0);
s = string.Format("{0}}", arg0);
s = string.Format("{-1}", arg0);
s = string.Format("{0} {1}", arg0);
</pre>
<h2>合规的解决方案</h2>
<pre>
s = string.Format("{0}", 42); // 合规
s = string.Format("{0,10}", 42); // 合规
s = string.Format("{0,-10}", 42); // 合规
s = string.Format("{0:0000}", 42); // 合规
s = string.Format("{2}-{0}-{1}", 1, 2, 3); // 合规
s = string.Format("no format"); // 合规
</pre>
<h2>例外</h2>
<ul>
  <li> 如果格式化字符串不是 <code>const</code> 型则不会引发问题。 </li>
</ul>
<pre>
var pattern = "{0} {1} {2}";
var res = string.Format(pattern, 1, 2); // 合规，只识别字符串常量
</pre>
<ul>
  <li> 如果参数不是内联创建的数组，则不会引发问题。 </li>
</ul>
<pre>
var array = new int[] {};
var res = string.Format("{0} {1}", array); // 合规，不知道数组的大小
</pre>
<ul>
  <li> 此规则不检查格式化说明符（format specifier）（定义在 <code>:</code> 后）是否实际有效。 </li>
</ul>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/wQA1">CERT, FIO47-C.</a> - Use valid format strings </li>
</ul>

