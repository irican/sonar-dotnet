<p><code>ISerializable</code> 接口是控制类型序列化过程的机制，如果没有经过正确的实现，它可能会导致无效的序列化，而且很难检测到bug。</p>
<p>此规则会对没有遵循Microsoft建议的序列化格式实现 <code>ISerializable</code> 的类型引发一个问题。</p>
<p>具体来说，此规则会检查下列问题：</p>
<ul>
  <li> <code>System.SerializableAttribute</code> 特性丢失。</li>
  <li> 无 <code>System.NonSerializedAttribute</code> 特性的不可序列化字段。 </li>
  <li> 无序列化构造函数。 </li>
  <li> 未密封的类型拥有非 <code>protected</code> 型的序列化构造函数。 </li>
  <li> 密封的类型拥有非 <code>private</code> 型的序列化构造函数。 </li>
  <li> 未密封的类型拥有既不是 <code>public</code> 也不是 <code>virtual</code> 型的 <code>ISerializable.GetObjectData</code>。 </li>
  <li> 派生类型拥有未调用 <code>base</code> 构造函数的序列化构造函数。 </li>
  <li> 派生类型拥有未调用 <code>base</code> 方法的 <code>ISerializable.GetObjectData</code> 方法。 </li>
  <li> 派生类型拥有可序列化字段但没有重写 <code>ISerializable.GetObjectData</code> 方法. </li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
public class Foo : ISerializable // 不合规，[Serializable]特性丢失
{
}
</pre>
<p>或者</p>
<pre>
public class Bar
{
}

[Serializable]
public class Foo : ISerializable // 不合规，序列化构造函数丢失
{
    private readonly Bar bar; // 不合规，该字段没有用[NonSerialized]标记
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Bar
{
}

[Serializable]
public class Foo : ISerializable
{
    [NonSerialized]
    private readonly Bar bar;

    public Foo()
    {
        // ……
    }

    protected Foo(SerializationInfo info, StreamingContext context)
    {
        // ……
    }

    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        // ……
    }
}

[Serializable]
public sealed class SubFoo : Foo
{
    private int val;

    public SubFoo()
    {
        // ……
    }

    private SubFoo(SerializationInfo info, StreamingContext context)
        : base(info, context)
    {
        // ……
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        base.GetObjectData(info, context);
        // ……
    }
}
</pre>
<h2>例外</h2>
<ul>
  <li> 测试项目里的类不做检查。 </li>
</ul>

