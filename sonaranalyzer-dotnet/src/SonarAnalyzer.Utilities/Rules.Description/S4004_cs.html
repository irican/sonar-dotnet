<p>可写的集合属性可以被完全不同的集合替换。设置为 <code>readonly</code> 可以防止这样做，同时仍然允许设置单个成员。如果您希望替换整个集合，推荐的模式是实现一个方法来删除所有元素(例如：<code>System.Collections.List&lt;T&gt;.Clear</code>) 和一个方法来填充集合(例如：<code>System.Collections.List&lt;T&gt;.AddRange</code>)。</p>
<p>当外部可见的可写属性是实现<code>System.Collections.ICollection</code>或 <code>System.Collections.Generic.ICollection&lt;T&gt;</code>的类型时，该规则会引发一个问题。</p>
<h2>不合规的代码示例</h2>
<pre>
using System;
using System.Collections;

namespace MyLibrary
{
  public class Foo
  {
    List&lt;string&gt; strings;

    public List&lt;string&gt; SomeStrings
    {
      get { return strings; }
      set { strings = value; } // 不合规
    }
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
using System;
using System.Collections;

namespace MyLibrary
{
  public class Foo
  {
    List&lt;string&gt; strings;

    public readonly List&lt;string&gt; SomeStrings
    {
      get { return strings; }
    }
  }
}
</pre>
<h2>例外</h2>
<p>此规则不会对 <code>string</code>，<code>Array</code> 和 <code>PermissionSet</code>产生问题。</p>

