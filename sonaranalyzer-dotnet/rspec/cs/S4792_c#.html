<p>配置记录器是安全敏感的。它在过去导致了以下漏洞：</p>
<ul>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0285">CVE-2018-0285</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1127">CVE-2000-1127</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-15113">CVE-2017-15113</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5742">CVE-2015-5742</a> </li>
</ul>
<p>日志在安全事件之前、期间和之后都很有用。</p>
<ul>
  <li> 大多数时候，攻击者会通过探测系统的漏洞来开始他们邪恶的工作。监视此活动并阻止它是防止攻击发生的第一步。</li>
  <li> 如果攻击成功，日志应该包含足够的信息来理解攻击者可能造成的破坏。</li>
</ul>
<p>日志也是攻击者的目标，因为它们可能包含敏感信息。配置记录器对记录的信息类型和记录方式有影响。</p>
<p>此规则标记用于初始化日志记录器配置的评审代码。目标是指导安全代码审查。</p>
<h2>检查是否有下列问题：</h2>
<ul>
  <li> 未经授权的用户可以访问日志，这可能是因为日志存储在不安全的位置，也可能是因为应用程序允许访问日志。</li>
  <li> 日志包含生产服务器上的敏感信息。这可能发生在日志程序处于调试模式时。</li>
  <li> 日志可以无限制增长。当用户每次执行一个操作时都将附加信息写入日志中，并且用户可以任意多次执行该操作时，就会发生这种情况。</li>
  <li> 日志中没有包含足够的信息来理解攻击者可能造成的破坏。日志记录器模式(info、warn、error)可能会过滤掉重要信息。它们可能不会打印上下文信息，如事件的精确时间或服务器主机名。</li>
  <li> 日志只存储在本地，而不是备份或复制。</li>
</ul>
<p>如果对其中任何一个问题的回答是肯定的，那么就有风险。</p>
<h2>推荐的安全编码实践</h2>
<ul>
  <li> 检查生产部署是否处于“调试”模式，因为它可能在日志中写入敏感信息。</li>
  <li> 生产日志应该存储在只有系统管理员才能访问的安全位置。</li>
  <li> 配置日志记录器以显示所有警告、信息和错误消息。编写相关信息，例如事件的准确时间和主机名。</li>
  <li> 选择易于自动解析和处理的日志格式。在发生攻击时，快速处理日志非常重要，这样才能知道和限制影响。</li>
  <li> 检查日志文件的权限是否正确。如果在其他服务中索引日志，请确保传输和服务也是安全的。</li>
  <li> 添加日志大小的限制，并确保没有用户可以用日志填充磁盘。即使用户不控制所记录的信息，也会发生这种情况。攻击者可以多次重复已记录的操作。</li>
</ul>
<p>请记住，正确配置日志记录器并不能使它们防攻击。以下是一些关于如何使用日志的建议：</p>
<ul>
  <li> 不要记录任何敏感信息。这显然包括密码和信用卡号码，但也包括任何个人信息，如用户名、位置等。通常，任何受法律保护的信息都有可能被删除。</li>
  <li> 在将所有用户输入写入日志之前对其进行净化。这包括检查它的大小、内容、编码、语法等等。对于任何用户输入，尽可能使用白名单进行验证。允许用户在日志中编写他们想要的内容可能会产生很多影响。
  例如，它可以使用您所有的存储空间，或者破坏您的日志索引服务。</li>
  <li> 记录足够的信息来监视可疑的活动，并评估攻击者可能对您的系统造成的影响。注册事件，如登录失败、登录成功、服务器端输入验证失败、访问拒绝和任何重要事务。</li>
  <li> 监视日志中的任何可疑活动。</li>
</ul>
<h2>可疑的代码示例</h2>
<p><strong>.Net Core</strong>：以编程方式配置</p>
<pre>
using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.AspNetCore;

namespace MvcApp
{
    public class ProgramLogging
    {
        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;
            WebHost.CreateDefaultBuilder(args)
                .ConfigureLogging((hostingContext, logging) =&gt; // 可疑的
                {
                    // ...
                })
                .UseStartup&lt;StartupLogging&gt;();
    }

    public class StartupLogging
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddLogging(logging =&gt; // 可疑的
            {
                // ...
            });
        }

        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            IConfiguration config = null;
            LogLevel level = LogLevel.Critical;
            Boolean includeScopes = false;
            Func&lt;string,Microsoft.Extensions.Logging.LogLevel,bool&gt; filter = null;
            Microsoft.Extensions.Logging.Console.IConsoleLoggerSettings consoleSettings = null;
            Microsoft.Extensions.Logging.AzureAppServices.AzureAppServicesDiagnosticsSettings azureSettings = null;
            Microsoft.Extensions.Logging.EventLog.EventLogSettings eventLogSettings = null;

            // 每次调用添加日志记录器的ILoggerFactory扩展方法都会引发一个问题。
            loggerFactory.AddAzureWebAppDiagnostics(); // 可疑的
            loggerFactory.AddAzureWebAppDiagnostics(azureSettings); // 可疑的
            loggerFactory.AddConsole(); // 可疑的
            loggerFactory.AddConsole(level); // 可疑的
            loggerFactory.AddConsole(level, includeScopes); // 可疑的
            loggerFactory.AddConsole(filter); // 可疑的
            loggerFactory.AddConsole(filter, includeScopes); // 可疑的
            loggerFactory.AddConsole(config); // 可疑的
            loggerFactory.AddConsole(consoleSettings); // 可疑的
            loggerFactory.AddDebug(); // 可疑的
            loggerFactory.AddDebug(level); // 可疑的
            loggerFactory.AddDebug(filter); // 可疑的
            loggerFactory.AddEventLog(); // 可疑的
            loggerFactory.AddEventLog(eventLogSettings); // 可疑的
            loggerFactory.AddEventLog(level); // 可疑的
            loggerFactory.AddEventSourceLogger(); // 可疑的

            IEnumerable&lt;ILoggerProvider&gt; providers = null;
            LoggerFilterOptions filterOptions1 = null;
            IOptionsMonitor&lt;LoggerFilterOptions&gt; filterOptions2 = null;

            LoggerFactory factory = new LoggerFactory(); // 可疑的
            new LoggerFactory(providers); // 可疑的
            new LoggerFactory(providers, filterOptions1); // 可疑的
            new LoggerFactory(providers, filterOptions2); // 可疑的
        }
    }
}
</pre>
<p><strong>Log4Net</strong></p>
<pre>
using System;
using System.IO;
using System.Xml;
using log4net.Appender;
using log4net.Config;
using log4net.Repository;

namespace Logging
{
    class Log4netLogging
    {
        void Foo(ILoggerRepository repository, XmlElement element, FileInfo configFile, Uri configUri, Stream configStream,
        IAppender appender, params IAppender[] appenders) {
            log4net.Config.XmlConfigurator.Configure(repository); // 可疑的
            log4net.Config.XmlConfigurator.Configure(repository, element); // 可疑的
            log4net.Config.XmlConfigurator.Configure(repository, configFile); // 可疑的
            log4net.Config.XmlConfigurator.Configure(repository, configUri); // 可疑的
            log4net.Config.XmlConfigurator.Configure(repository, configStream); // 可疑的
            log4net.Config.XmlConfigurator.ConfigureAndWatch(repository, configFile); // 可疑的

            log4net.Config.DOMConfigurator.Configure(); // 可疑的
            log4net.Config.DOMConfigurator.Configure(repository); // 可疑的
            log4net.Config.DOMConfigurator.Configure(element); // 可疑的
            log4net.Config.DOMConfigurator.Configure(repository, element); // 可疑的
            log4net.Config.DOMConfigurator.Configure(configFile); // 可疑的
            log4net.Config.DOMConfigurator.Configure(repository, configFile); // 可疑的
            log4net.Config.DOMConfigurator.Configure(configStream); // 可疑的
            log4net.Config.DOMConfigurator.Configure(repository, configStream); // 可疑的
            log4net.Config.DOMConfigurator.ConfigureAndWatch(configFile); // 可疑的
            log4net.Config.DOMConfigurator.ConfigureAndWatch(repository, configFile); // 可疑的

            log4net.Config.BasicConfigurator.Configure(); // 可疑的
            log4net.Config.BasicConfigurator.Configure(appender); // 可疑的
            log4net.Config.BasicConfigurator.Configure(appenders); // 可疑的
            log4net.Config.BasicConfigurator.Configure(repository); // 可疑的
            log4net.Config.BasicConfigurator.Configure(repository, appender); // 可疑的
            log4net.Config.BasicConfigurator.Configure(repository, appenders); // 可疑的
        }
    }
}
</pre>
<p><strong>NLog</strong>：以编程方式配置</p>
<pre>
namespace Logging
{
    class NLogLogging
    {
        void Foo(NLog.Config.LoggingConfiguration config) {
            NLog.LogManager.Configuration = config; // 可疑的，这将更改日志配置。
        }
    }
}
</pre>
<p><strong>Serilog</strong></p>
<pre>
namespace Logging
{
    class SerilogLogging
    {
        void Foo() {
            new Serilog.LoggerConfiguration(); // 可疑的
        }
    }
}
</pre>
<h2>请参阅<h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/532.html">MITRE, CWE-532</a> - Information Exposure Through Log Files </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/117.html">MITRE, CWE-117</a> - Improper Output Neutralization for Logs </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/778.html">MITRE, CWE-778</a> - Insufficient Logging </li>
  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
  <li> OWASP Top 10 2017 Category A10 - Insufficient Logging &amp; Monitoring </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat3">SANS Top 25</a> - Porous Defenses </li>
</ul>
