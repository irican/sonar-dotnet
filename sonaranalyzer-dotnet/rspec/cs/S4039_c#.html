<p>当基类型显式实现公共接口方法时，该方法只能通过对当前实例的引用 (即<code>this</code>)在派生类型中访问。如果派生类型显式重写该接口方法，则无法访问基实现。</p>
<p>当打开外部可见的类型提供 <code>public interface</code> 的显式方法实现时，此规则会引发一个问题，并且不提供具有相同名称的替代外部可见方法。</p>
<h2>不合规的代码示例</h2>
<pre>
public interface IMyInterface
{
    void MyMethod();
}

public class Foo : IMyInterface
{
    void IMyInterface.MyMethod() //  不合规
    {
        MyMethod();
    }

    void MyMethod()
    {
        // 实现一些功能
    }
}

public class Bar : Foo, IMyInterface
{
    public void MyMethod()
    {
        // 无法访问 base.MyMethod()
        // ((IMyInterface)this).MyMethod() 将会成为递归调用
    }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public interface IMyInterface
{
    void MyMethod();
}

public class Foo : IMyInterface
{
    void IMyInterface.MyMethod()
    {
        MyMethod();
    }

    protected void MyMethod() // 或 public
    {
        //实现一些功能
    }
}

public class Bar : Foo, IMyInterface
{
    public void MyMethod()
    {
        // 实现一些功能
        base.MyMethod();
    }
}
</pre>
<h2>例外</h2>
<p>当提供外部可见的<code>Close()</code> 或 <code>System.IDisposable.Dispose(Boolean)</code>方法时，该规则不会报告对<code>IDisposable.Dispose</code> 显式实现的违反。</p>

