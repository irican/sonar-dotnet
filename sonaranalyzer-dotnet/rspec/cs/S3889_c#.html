<p><code>Thread.Suspend</code> 和 <code>Thread.Resume</code> 可能会产生不可预知的效果，并且这两种方法都已被弃用。事实上，如果 <code>Thread.Suspend</code> 使用得不够仔细，它可能会让某个线程在挂起的同时还持有锁，并由此导致死锁的发生。应使用其他较为安全的同步机制，如 <code>Monitor</code>，<code>Mutex</code> 与 <code>Semaphore</code>。</p>
<h2>不合规的代码示例</h2>
<pre>
static void Main(string[] args)
{
  // ...
  Thread.CurrentThread.Suspend(); // 不合规
  Thread.CurrentThread.Resume(); // 不合规
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread.resume.aspx">Thread.Resume Method ()</a> </li>
  <li> <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread.suspend(v=vs.110).aspx">Thread.Suspend Method ()</a> </li>
</ul>

